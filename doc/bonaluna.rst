..  BonaLuna

..  Copyright (C) 2010-2013 Christophe Delord
    http://www.cdsoft.fr/bl/bonaluna.html

..  BonaLuna is based on Lua 5.2
    Copyright (C) 2010 Lua.org, PUC-Rio.

..  Freely available under the terms of the Lua license.

=================
 |logo| BonaLuna
=================
-------------------------
 A compact Lua extension
-------------------------

.. |logo| image:: bl.png
.. |logo_lua| image:: http://www.andreas-rozek.de/Lua/Lua-Logo_64x64.png

.. sidebar:: Based on `Lua 5.2 <http://www.lua.org>`__ |logo_lua|

    Copyright (C) 2010 `Lua.org <http://www.lua.org>`__, PUC-Rio.

:Author: Christophe Delord
:Contact: http://cdsoft.fr/contact.html
:Web: http://cdsoft.fr/bl/bonaluna.html
:License:
    | Copyright (C) 2010-2013 Christophe Delord,
      `CDSoft.fr <http://cdsoft.fr/bl/bonaluna.html>`__
    | Freely available under the terms of the
      `Lua license <http://www.lua.org/license.html#5>`__
    | **Lua**, **Lpeg**: `Lua license <http://www.lua.org/license.html#5>`__
    | **miniLZO**, **QuickLZ**: GPL v2
    | **LZ4**: BSD
    | **libcurl**: `MIT/X derivate <http://curl.haxx.se/docs/copyright.html>`__
:Download: http://cdsoft.fr/bl/bonaluna-2.3.4.tgz

:Version: 2.3.4
:Abstract:
    BonaLuna is a Lua interpretor plus a few packages
    in a single executable.

.. contents:: Table of Contents
    :depth: 2

.. sectnum::
    :depth: 2

Lua
===

The original Lua interpretor and documentation is available
at http://www.lua.org.

BonaLuna is based on `Lua 5.2 <lua/contents.html>`__.

Global functions
================

Iterators
---------

**iter(sequence)** returns an iterator of `sequence` items (a table).

**list(iterator)** returns a table of items generated by `iterator`.

**reverse(iterator)** returns `iterator` in reverse order.

**sort(iterator [, cmp])** returns `iterator` sorted using `cmp` (as `table.sort`)

**map(f, ...)** applies `f` to iterators.

**zip(...)** groups values of the same rank of several iterators.

**filter(p, ...)** selects values according to the predicate `p`.

**range(i [, j [, s] ])** returns the values of the range [`i`, `j`].
`s`Â is the step.
`range(j)` is equivalent to `range(1, j)`. The default step is 1.

**enum(iterator)** generates tuples `(i, x[i])` where `i` is the rank of the value `x[i]` for each value of `iterator`.

**chain(...)** chains several iterators.

BonaLuna packages
=================

Note about objects
------------------

Objects defined in these packages uses closures [#]_ to store internal data.
No *self* is required and methods are called with a single dot (`.`),
not with a colon (`:`).

Example::

    aes = crypt.AES("my key", 128)
    encrypted = aes.encrypt("some text")

.. [#] See `Object Orientation Closure Approach <http://lua-users.org/wiki/ObjectOrientationClosureApproach>`__.

bc, m: arbitrary precision library for Lua based on GNU bc
----------------------------------------------------------

lbc is a public domain package written by Luiz Henrique de Figueiredo and available at 
`Libraries and tools for Lua <http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#lbc>`__

This is a big-number library for Lua 5.2. It is based on the arbitrary
precision library number.c written by Philip A. Nelson for GNU bc-1.06:
http://www.gnu.org/software/bc/

basic bc functions
~~~~~~~~~~~~~~~~~~

**bc.version** is the version number of bc

**bc.digits([n])** sets the number of digits used by bc

**bc.number(x)** builds a big number from a Lua number or a string

**bc.tonumber(x)** converts a big number to a Lua number

**bc.tostring(x), __tostring(x)** converts a big number to a string

**bc.neg(x), __unm(x)** returns ``-x``

**bc.add(x,y), __add(x,y)** returns ``x+y``

**bc.sub(x,y), __sub(x,y)** returns ``x-y``

**bc.mul(x,y), __mul(x,y)** returns ``x*y``

**bc.div(x,y), __div(x,y)** returns ``x/y``

**bc.mod(x,y), __mod(x,y)** return ``x mod y``

**bc.divmod(x,y)** returns ``[x/y], x mod y``

**bc.pow(x,y), __pow(x,y)** returns ``x**y``

**bc.powmod(x,y,m)** returns ``x**y mod m``

**bc.compare(x,y)** returns ``-1`` if x < y, ``0`` if x == y, ``+1`` if x > y

**__eq(x,y), __lt(x,y)** compares x and y

**bc.iszero(x)** is true if x == 0

**bc.isneg(x)** is true if x < 0

**bc.trunc(x,[n])** returns x truncated value

**bc.sqrt(x)** returns ``sqrt(x)``

Functions added by BonaLuna
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**bc.number(x)** also accepts hexadecimal, octal and binary numbers as strings

Math and bitwise operators
~~~~~~~~~~~~~~~~~~~~~~~~~~

Functions of the math and bit32 modules also exist in the bc module.
These functions produce bc numbers but work internally with Lua numbers.
Do not expect these functions to be precise.

m package
~~~~~~~~~

The m package extends the bc package by mixing arbitrary precision integer (bc)
and Lua numbers (float). It produces bc integers when possible and Lua numbers
otherwise.


bn: arbitrary precision library for Lua written in pure Lua
-----------------------------------------------------------

basic bn functions
~~~~~~~~~~~~~~~~~~

**bn.Int(x)** builds a big integer from a Lua number, a string or a big number

**bn.Rat(x)** builds a big rational from a Lua number, a string or a big number

**bn.Float(x)** builds a float from a Lua number, a string or a big number

**bn.tonumber(x)** converts a big number to a Lua number

**bn.tostring(x, base, bits), __tostring(x)** converts a big number to a string

**__unm(x)** returns ``-x``

**__add(x,y)** returns ``x+y``

**__sub(x,y)** returns ``x-y``

**__mul(x,y)** returns ``x*y``

**__div(x,y)** returns ``x/y``

**__mod(x,y)** return ``x mod y``

**bn.divmod(x,y)** returns ``[x/y], x mod y``

**__pow(x,y)** returns ``x**y``

**__eq(x,y), __lt(x,y)** compares x and y

**x:iszero()** is true if x == 0

**x:isone()** is true if x == 1

Math and bitwise operators
~~~~~~~~~~~~~~~~~~~~~~~~~~

Functions of the math and bit32 modules also exist in the bn module.
These functions produce bn numbers but may work internally with Lua numbers.
Do not expect these functions to be precise.


crypt: Cryptographic functions
------------------------------

The `crypt` package is a pure Lua package (i.e. not really fast).

**crypt.hex.encode(data)** encodes `data` in hexa.

**crypt.hex.decode(data)** decodes the hexa `data`.

**crypt.base64.encode(data)** encodes `data` in base64.

**crypt.base64.decode(data)** decodes the base64 `data`.

**crypt.crc32(data)** computes the CRC32 of `data`.

**crypt.shaXXX(data)** computes an SHA digest of `data`. `XXX` is 1, 224 or 256.

**crypt.AES(password [,keylen [,mode] ])** returns an AES codec.
`password` is the encryption/decryption key, `keylen` is the length
of the key (128 (default), 192 or 256), `mode` is the encryption/decryption
mode ("cbc" (default) or "ecb").
`crypt.AES` objects have two methods: `encrypt(data)` and `decrypt(data)`.

**crypt.random(bits)** returns a string with `bits` random bits.


curl: libcurl interface
-----------------------

`libcurl <http://curl.haxx.se/>`__ is multiprotocol file transfer library.
This package is a simple Lua interface to libcurl.

This package is based on `Lua-cURL <http://luaforge.net/projects/lua-curl/>`__
and provides the same API plus a few higher level objects.

This package was introduced before `socket` which is based on `Lua Socket`.
I recommend using `socket` instead of `curl`.

**curl.FTP(url [, login, password])** creates an FTP object to connect to
the FTP server at `url`. `login` and `password` are optional.
Methods are:

    - `cd(path)` changes the *current working directory*. No connection is
      made, `path` is just stored internally for later connections.

    - `get(path)` retrieves `path`.

    - `put(path, data)` sends and stores the string `data` to the file `path`.

    - `rm(path)` deletes the file `path`.

    - `mkdir(path)` creates the directory `path`.

    - `rmdir(path)` deletes the directory `path`.

    - `list(path)` returns an iterator listing the directory `path`.

FTP connections are made through the cURL easy interface, each request is in
fact an entire connection (and deconnection).

**curl.HTTP(url)** creates an HTTP object to connect to the HTTP server at `url`.
Methods are:

    - `get(path)` retrieves `path`.

    - `save(path [, name])` retrieves `path` and saves it to `name`.
      The default value of `name` is the basename of `path`.

fs: File System
---------------

**fs.getcwd()** returns the current working directory.

**fs.chdir(path)** changes the current directory to `path`.

**fs.listdir([path])** returns the list of files and directories in
`path` (the default path is the current directory).

**fs.dir([path])** returns an iterator listing files and directories in
`path` (the default path is the current directory).

**fs.walk([path])** returns an iterator listing directory and file names
in `path` and its subdirectories (the default path is the current directory).

**fs.mkdir(path)** creates a new directory `path`.

**fs.rename(old_name, new_name)** renames the file `old_name` to `new_name`.

**fs.remove(name)** deletes the file `name`.

**fs.copy(source_name, target_name)** copies file `source_name` to `target_name`.
The attributes and times are preserved.

**fs.stat(name)** reads attributes of the file `name`.  Attributes are:

    - `name`: name
    - type: "file" or "directory"
    - `size`: size in bytes
    - `mtime`, `atime`, `ctime`: modification, access and creation times.
    - `mode`: file permissions
    - `uR`, `uW`, `uX`: user Read/Write/eXecute permissions
    - `gR`, `gW`, `gX`: group Read/Write/eXecute permissions
    - `oR`, `oW`, `oX`: other Read/Write/eXecute permissions

**fs.inode(name)** reads device and inode attributes of the file `name`.
Attributes are:

    - `dev`, `ino`: device and inode numbers


**fs.chmod(name, other_file_name)** sets file `name` permissions as
file `other_file_name` (string containing the name of another file).

**fs.chmod(name, bit1, ..., bitn)** sets file `name` permissions as
`bit1` or ... or `bitn` (integers).

**fs.touch(name)** sets the access time and the modification time of file `name` with the current time.

**fs.touch(name, number)** sets the access time and the modification time of file `name` with `number`.

**fs.touch(name, other_name)** sets the access time and the modification time of file `name` with the times of file `other_name`.

**fs.basename(path)** return the last component of path.

**fs.dirname(path)** return all but the last component of path.

**fs.absname(path)** return the absolute path name of path.


**fs.sep** is the directory separator (/ or \\).

**fs.uR, fs.uW, fs.uX** are the User Read/Write/eXecute mask for `fs.chmod`.

**fs.gR, fs.gW, fs.gX** are the Group Read/Write/eXecute mask for `fs.chmod`.

**fs.oR, fs.oW, fs.oX** are the Other Read/Write/eXecute mask for `fs.chmod`.

**fs.aR, fs.aW, fs.aX** are All Read/Write/eXecute mask for `fs.chmod`.

lpeg, re: parsing library
-------------------------

Bonaluna parsing library is Lpeg.
Both lpeg and re modules are loaded when Bonaluna is started.

The documentation of these modules are available on Lpeg web site:
- `Lpeg <http://www.inf.puc-rio.br/~roberto/lpeg/>`__
- `Re <http://www.inf.puc-rio.br/~roberto/lpeg/re.html>`__

z, lzo, qlz, lz4, zlib, ucl, lzma: compression libraries
--------------------------------------------------------

Compression libraries are based on:
- `LZO <http://www.oberhumer.com/opensource/lzo/>`__
- `QuickLZ <http://www.quicklz.com/>`__
- `LZ4/LZ4HC <http://code.google.com/p/lz4/>`__
- `ZLIB <http://www.zlib.net/>`__
- `UCL <http://www.oberhumer.com/opensource/ucl/>`__
- `XZ Utils <http://tukaani.org/xz/>`__

It's inspired by the `Lua Lzo module <http://lua-users.org/wiki/LuaModuleLzo>`__.

Future versions of BonaLuna may remove or add some compression library.

Currently, only zlib is used in the default BonaLuna distribution
but you can change it in `setup`.

**z.compress(data)** compresses `data` using the best compressor and returns the compressed string.

**z.decompress(data)** decompresses `data` and returns the decompressed string.

**minilzo.compress(data)** compresses `data` with miniLZO and returns the compressed string.

**minilzo.decompress(data)** decompresses `data` with miniLZO and returns the decompressed string.

**lzo.compress(data)** compresses `data` with LZO and returns the compressed string.

**lzo.decompress(data)** decompresses `data` with LZO and returns the decompressed string.

**qlz.compress(data)** compresses `data` with QLZ and returns the compressed string.

**qlz.decompress(data)** decompresses `data` with QLZ and returns the decompressed string.

**lz4.compress(data)** compresses `data` with LZ4 and returns the compressed string.

**lz4.decompress(data)** decompresses `data` with LZ4 and returns the decompressed string.

**lz4hc.compress(data)** compresses `data` with LZ4HC and returns the compressed string.

**lz4hc.decompress(data)** decompresses `data` with LZ4HC and returns the decompressed string.

**zlib.compress(data)** compresses `data` with ZLIB and returns the compressed string.

**zlib.decompress(data)** decompresses `data` with ZLIB and returns the decompressed string.

**ucl.compress(data)** compresses `data` with UCL and returns the compressed string.

**ucl.decompress(data)** decompresses `data` with UCL and returns the decompressed string.

**lzma.compress(data)** compresses `data` with XZ Utils and returns the compressed string.

**lzma.decompress(data)** decompresses `data` with XZ Utils and returns the decompressed string.

ps: Processes
-------------

**ps.sleep(n)** sleeps for `n` seconds.

rl: readline
------------

The rl (readline) package was initially inspired by
`ilua <https://github.com/ilua>`_
and adapted for BonaLuna.

**rl.read(prompt)** prints `prompt` and returns the string entered by the user.

**rl.add(line)** adds `line` to the readline history (Linux only).


socket: Lua Socket (and networking tools)
-----------------------------------------

The socket package is based on `Lua Socket <http://w3.impa.br/~diego/software/luasocket/>`__
and adapted for BonaLuna.

The documentation of `Lua Socket` is available at the `Lua Socket documentation web site <http://w3.impa.br/~diego/software/luasocket/reference.html>`_.

This package also comes with the following functions.

**FTP(url [, login, password])** creates an FTP object to connect to
the FTP server at `url`. `login` and `password` are optional.
Methods are:

    - `cd(path)` changes the current working directory.

    - `pwd()` returns the current working directory.

    - `get(path)` retrieves `path`.

    - `put(path, data)` sends and stores the string `data` to the file `path`.

    - `rm(path)` deletes the file `path`.

    - `mkdir(path)` creates the directory `path`.

    - `rmdir(path)` deletes the directory `path`.

    - `list(path)` returns an iterator listing the directory `path`.

struct: (un)pack structures
---------------------------

The struct package is taken from
`Library for Converting Data to and from C Structs for Lua 5.1 <http://www.inf.puc-rio.br/~roberto/struct/>`_
and adapted for BonaLuna.

**struct.pack(fmt, d1, d2, ...)** returns a string containing the values `d1`, `d2`, etc. packed according to the format string `fmt`.

**struct.unpack(fmt, s, [i])** returns the values packed in string `s` according to the format string `fmt`. An optional `i` marks where in `s` to start reading (default is 1). After the read values, this function also returns the index in `s` where it stopped reading, which is also where you should start to read the rest of the string.

**struct.size(fmt)** returns the size of a string formatted according to the format string `fmt`. For obvious reasons, the format string cannot contain neither the option `s` nor the option `c0`.

sys: System management
----------------------

**sys.hostname()** returns the host name.

**sys.domainname()** returns the domain name.

**sys.hostid()** returns the host id.

**sys.platform** is `"Linux"` or `"Windows"`

Self running scripts
====================

It is possible to add scripts to the BonaLuna interpretor
to make a single executable file containing the interpretor
and some BonaLuna scripts.

This feature is inspired by
`srlua <http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#srlua>`__.

`pegar.lua` parameters
----------------------

**compile:on|off|min** turn compilation on, off or on when chunks are smaller than sources (`min` is the default value)

**compress:on|off|min** turn compression on, off or on when chunks are smaller than sources (`min` is the default value)

**read:original_interpretor** reads the initial interpretor

**lua:script.lua** adds a script to be executed at runtime

**lua:script.lua=realname.lua** as above but stored under a different name

**str:name=value** creates a global variable holding a string

**str:name=@filename** as above but the string is the content of a file

**file:name** adds a file to be created at runtime (the file is not overwritten if it already exists)

**file:name=realname** as above but stored under a different name

**dir:name** creates a directory at runtime

**write:new_executable** write a new executable containing the original interpretor and all the added items

When a path starts with `:`, it is relative to the executable path otherwise
it is relative to the current working directory.


Examples
========

This documentation has been generated by a BonaLuna script.
`bonaluna.lua <bonaluna.lua>`__ also contains some tests.

