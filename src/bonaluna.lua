--[[ BonaLuna test and documentation generator

Copyright (C) 2010-2014 Christophe Delord
http://cdsoft.fr/bl/bonaluna.html

BonaLuna is based on Lua 5.3
Copyright (C) 1994-2013 Lua.org, PUC-Rio

Freely available under the terms of the Lua license.

--]]

do
    local bl_md = "../doc/bonaluna.md"
    function doc(txt)
        local f = assert(io.open(bl_md, "a"))
        f:write(txt)
        f:write("\n")
        f:close()
    end
    os.remove(bl_md)
end

function p(fmt, ...)
    io.stderr:write(string.format(fmt, ...).."\n")
end

BONALUNA_VERSION = _BL_VERSION:split(" ")[2]

doc([[
% BonaLuna - A compact Lua extension
% [Christophe Delord](http://cdsoft.fr/contact.html)
% Documentation date: ]] .. os.date() .. [[


<!--
BonaLuna

Copyright (C) 2010-2014 Christophe Delord
http://www.cdsoft.fr/bl/bonaluna.html

BonaLuna is based on Lua 5.3
Copyright (C) 2010 Lua.org, PUC-Rio.

Freely available under the terms of the Lua license.
-->

[logo]: bl.png
[logo_lua]: http://www.andreas-rozek.de/Lua/Lua-Logo_64x64.png

Abstract
========

![logo][] [BonaLuna](http://cdsoft.fr/bl/bonaluna.html) is a Lua interpretor plus a few packages in a single executable.

The current version is ]]..BONALUNA_VERSION..[[


Licenses
--------

* ![logo][] **[BonaLuna](http://cdsoft.fr/bl/bonaluna.html)**: Copyright (C) 2010-2014 Christophe Delord, Freely available under the terms of the [Lua license](http://www.lua.org/license.html#5)
* ![logo_lua][] **[Lua 5.3](http://www.lua.org)**: Copyright (C) 2010 [Lua.org](http://www.lua.org>), PUC-Rio.
* **Lua**, **Lpeg**: [Lua license](http://www.lua.org/license.html#5)
* **miniLZO**, **QuickLZ**: GPL v2
* **LZ4**: BSD
* **LZF**: GPL
* **libcurl**: [MIT/X derivate](http://curl.haxx.se/docs/copyright.html)
* **ser**: MIT license

Download
--------

[BonaLuna](http://cdsoft.fr/bl/bonaluna.html) can be downloaded here: [bonaluna-]]..BONALUNA_VERSION..[[.tgz](http://cdsoft.fr/bl/bonaluna-]]..BONALUNA_VERSION..[[.tgz)

]])

doc([[
Lua
===

The original Lua interpretor and documentation is available
at http://www.lua.org.

BonaLuna is based on []].._VERSION..[[](lua/contents.html).
]])

doc [[
Global functions
================
]]

doc [[
Iterators
---------

**iter(sequence)** returns an iterator of `sequence` items (a table).

**list(iterator)** returns a table of items generated by `iterator`.

**reverse(iterator)** returns `iterator` in reverse order.

**sort(iterator [, cmp])** returns `iterator` sorted using `cmp` (as `table.sort`)

**map(f, ...)** applies `f` to iterators.

**zip(...)** groups values of the same rank of several iterators.

**filter(p, iterator)** selects values according to the predicate `p`.

**range(i [, j [, s] ])** returns the values of the range [`i`, `j`].
`s`Â is the step.
`range(j)` is equivalent to `range(1, j)`. The default step is 1.

**enum(iterator)** generates tuples `(i, x[i])` where `i` is the rank of the value `x[i]` for each value of `iterator`.

**chain(...)** chains several iterators.
]]

do
    -- iter
    local L1 = {"a", "b", "c"}
    local L2 = {}
    for x in iter(L1) do table.insert(L2, x) end
    assert(#L2 == 3)
    assert(L2[1] == L1[1])
    assert(L2[2] == L1[2])
    assert(L2[3] == L1[3])
    -- list
    L2 = list(iter(L1))
    assert(#L2 == 3)
    assert(L2[1] == L1[1])
    assert(L2[2] == L1[2])
    assert(L2[3] == L1[3])
    -- reverse
    L2 = list(reverse(L1))
    assert(#L2 == 3)
    assert(L2[1] == L1[3])
    assert(L2[2] == L1[2])
    assert(L2[3] == L1[1])
    -- sort
    L2 = list(sort(reverse(L1)))
    assert(#L2 == 3)
    assert(L2[1] == L1[1])
    assert(L2[2] == L1[2])
    assert(L2[3] == L1[3])
    L2 = {"c", "b", "a"}
    L3 = list(sort(L2)) -- no side effect, L2 shall not be sorted
    assert(L2[1] == "c" and L3[1] == "a")
    assert(L2[2] == "b" and L3[2] == "b")
    assert(L2[3] == "a" and L3[3] == "c")
    assert(#L2 == 3 and #L3 == 3)
    -- map
    L2 = list(map(string.upper, L1))
    assert(#L2 == 3)
    assert(L2[1] == L1[1]:upper())
    assert(L2[2] == L1[2]:upper())
    assert(L2[3] == L1[3]:upper())
    -- zip
    for i, x, y in enum(zip(L1, {4, 5, 6})) do
        assert(x == L1[i] and y == i+3)
    end
    -- filter
    L2 = list(filter(function(x) return x:byte()%2==1 end, L1))
    assert(#L2 == 2)
    assert(L2[1] == "a")
    assert(L2[2] == "c")
    -- range
    L2 = list(range(3, 10, 2))
    assert(#L2 == 4)
    assert(L2[1] == 3)
    assert(L2[2] == 5)
    assert(L2[3] == 7)
    assert(L2[4] == 9)
    L2 = list(range(10, 3, -2))
    assert(#L2 == 4)
    assert(L2[1] == 10)
    assert(L2[2] == 8)
    assert(L2[3] == 6)
    assert(L2[4] == 4)
    -- enum
    L2 = {}
    for i, x in enum(L1) do table.insert(L2, {i, x}) end
    assert(#L2 == 3)
    assert(L2[1][1] == 1 and L2[1][2] == "a")
    assert(L2[2][1] == 2 and L2[2][2] == "b")
    assert(L2[3][1] == 3 and L2[3][2] == "c")
    -- chain
    L2 = list(chain(L1, {"d", "e"}))
    assert(#L2 == 5)
    assert(L2[1] == "a")
    assert(L2[2] == "b")
    assert(L2[3] == "c")
    assert(L2[4] == "d")
    assert(L2[5] == "e")
end

doc [[
Higher order functions
----------------------

**curry(f, ...)** returns a curryfied function starting with f and its first arguments (...) if any.

**compose(f, g, ...)** returns the composed function "f(g(...))".

**identity** is the identity function.

**memoize(f)** returns a memoized function.
]]

do

    -- curry

    local function multiplyAndAdd(a,b,c) return a * b + c end
    multiplyAndAdd_curried = curry(multiplyAndAdd)

    multiplyBySevenAndAdd_v1 = multiplyAndAdd_curried(7)
    multiplyBySevenAndAdd_v2 = curry(multiplyAndAdd, 7)

    multiplySevenByEightAndAdd_v1 = multiplyAndAdd_curried(7, 8)
    multiplySevenByEightAndAdd_v2 = curry(multiplyAndAdd, 7, 8)
    multiplySevenByEightAndAdd_v3 = multiplyBySevenAndAdd_v1(8)
    multiplySevenByEightAndAdd_v4 = multiplyBySevenAndAdd_v2(8)

    multiplySevenByEightAndAddNine = curry(multiplyAndAdd, 7, 8, 9)

    for i = 1, 3 do
    assert(multiplyAndAdd(7, 8, 9) == multiplyBySevenAndAdd_v1(8, 9))
    assert(multiplyAndAdd(7, 8, 9) == multiplyBySevenAndAdd_v2(8, 9))
    assert(multiplyAndAdd(7, 8, 9) == multiplySevenByEightAndAdd_v1(9))
    assert(multiplyAndAdd(7, 8, 9) == multiplySevenByEightAndAdd_v2(9))
    assert(multiplyAndAdd(7, 8, 9) == multiplySevenByEightAndAdd_v3(9))
    assert(multiplyAndAdd(7, 8, 9) == multiplySevenByEightAndAdd_v4(9))
    assert(multiplyAndAdd(7, 8, 9) == multiplySevenByEightAndAddNine())
    end

    -- compose

    local cossin = function(x) return math.cos(x), math.sin(x) end
    local norm = function(x, y) return math.sqrt(x*x + y*y) end

    assert(compose(norm, cossin)(0.12) == 1.0)

    -- identity
    for i = 1, 10 do
        assert(identity(i) == i)
        assert(#table.pack(identity(i, 2*i)) == 2)
        assert(table.pack(identity(i, 2*i))[1] == i)
        assert(table.pack(identity(i, 2*i))[2] == 2*i)
    end

    -- memoize

    local function chrono(f)
        local t0 = os.clock()
        local res = f()
        return res, os.clock() - t0
    end

    local function fib(n)
        if n < 2 then return 1 else return fib(n-2) + fib(n-1) end
    end

    local N = 36
    local res1, t1 = chrono(function() return fib(N) end)
    fib = memoize(fib)
    local res2, t2 = chrono(function() return fib(N) end)

    assert(res1 == res2)
    assert(t2 < t1/1000)

    local add = memoize(function(a, ...)
        local sum = a or 0
        for i = 1, select("#", ...) do
            sum = sum + (select(i, ...) or 0)
        end
        return "[", sum, "]"
    end)

    for i = 1, 2 do
        local r
        for j = 1, 2 do r = table.pack(add(nil, 2))             assert(r[1] == "[" and r[2] == 2 and r[3] == "]") end
        for j = 1, 2 do r = table.pack(add(1, 2, nil, 3, nil))  assert(r[1] == "[" and r[2] == 6 and r[3] == "]") end
        for j = 1, 2 do r = table.pack(add(1, 2, 3))            assert(r[1] == "[" and r[2] == 6 and r[3] == "]") end
        for j = 1, 2 do r = table.pack(add(5, 6, 3))            assert(r[1] == "[" and r[2] == 14 and r[3] == "]") end
        for j = 1, 2 do r = table.pack(add(5, 6, 3, 4))         assert(r[1] == "[" and r[2] == 18 and r[3] == "]") end
    end

end

doc [[
BonaLuna packages
=================

Note about objects
------------------

Objects defined in these packages uses closures [^1] to store internal data.
No *self* is required and methods are called with a single dot (`.`),
not with a colon (`:`).

Example:

    aes = crypt.AES("my key", 128)
    encrypted = aes.encrypt("some text")

[^1]: See [Object Orientation Closure Approach](http://lua-users.org/wiki/ObjectOrientationClosureApproach).
]]

doc [[
bc, m: arbitrary precision library for Lua based on GNU bc
----------------------------------------------------------

lbc is a public domain package written by Luiz Henrique de Figueiredo and available at 
[Libraries and tools for Lua](http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#lbc)

This is a big-number library for Lua 5.3. It is based on the arbitrary
precision library number.c written by Philip A. Nelson for GNU bc-1.06:
http://www.gnu.org/software/bc/

### basic bc functions

**bc.version** is the version number of bc

**bc.digits([n])** sets the number of digits used by bc

**bc.number(x)** builds a big number from a Lua number or a string

**bc.tonumber(x)** converts a big number to a Lua number

**bc.tostring(x), \_\_tostring(x)** converts a big number to a string

**bc.neg(x), \_\_unm(x)** returns `-x`

**bc.add(x,y), \_\_add(x,y)** returns `x+y`

**bc.sub(x,y), \_\_sub(x,y)** returns `x-y`

**bc.mul(x,y), \_\_mul(x,y)** returns `x*y`

**bc.div(x,y), \_\_div(x,y)** returns `x/y`

**bc.mod(x,y), \_\_mod(x,y)** return `x mod y`

**bc.divmod(x,y)** returns `[x/y], x mod y`

**bc.pow(x,y), \_\_pow(x,y)** returns `x**y`

**bc.powmod(x,y,m)** returns `x**y mod m`

**bc.compare(x,y)** returns `-1` if x < y, `0` if x == y, `+1` if x > y

**\_\_eq(x,y), \_\_lt(x,y)** compares x and y

**bc.iszero(x)** is true if x == 0

**bc.isneg(x)** is true if x < 0

**bc.trunc(x,[n])** returns x truncated value

**bc.sqrt(x)** returns `sqrt(x)`

### Functions added by BonaLuna

**bc.number(x)** also accepts hexadecimal, octal and binary numbers as strings

### Math and bitwise operators

Functions of the math and bit32 modules also exist in the bc module.
These functions produce bc numbers but work internally with Lua numbers.
Do not expect these functions to be precise.

### m package

The m package extends the bc package by mixing arbitrary precision integer (bc)
and Lua numbers (float). It produces bc integers when possible and Lua numbers
otherwise.

]]

if bc then
    bc.digits(0)
    assert(bc.tonumber(bc.number("0x 1234 5678")) == 0x12345678)
    assert(bc.tonumber(bc.number("0x_1234_5678")) == 0x12345678)
    assert(bc.tonumber(bc.number("0o_1_234_567")) == 342391)
    assert(bc.tonumber(bc.number("0b_11110000")) == 0xF0)
    assert(bc.hex(bc.number("0x12345678")) == "0x 1234 5678")
    assert(bc.hex(bc.number("0x12345678"), 32) == "0x 1234 5678")
    assert(bc.hex(bc.number("0x12345678"), 16) == "0x 5678")
    assert(bc.hex(bc.number("0x12345678"), 8) == "0x 78")
    assert(bc.dec(bc.number("0x12345678")) == "305 419 896")
    assert(bc.oct(bc.number("0x12345678")) == "0o 2215053170")
    assert(bc.bin(bc.number("0x12345678")) == "0b 0001 0010 0011 0100 0101 0110 0111 1000")
    assert(bc.hex(bc.bnot(bc.number("0xAA55 FFFF 0000"), 64), 64) == "0x FFFF 55AA 0000 FFFF")
    assert(bc.hex(bc.band(bc.number("0x12345678"), bc.number("0x000F_F000"))) == "0x 0004 5000")
    assert(bc.hex(bc.bor(bc.number("0x12345678"), bc.number("0x000F_F000"))) == "0x 123F F678")
    assert(bc.hex(bc.bxor(bc.number("0xAAAA5555"), bc.number("0x00FF_FF00"))) == "0x AA55 AA55")
    assert(bc.btest(bc.number("0x12345678"), bc.number("0x000F_F000")))
    assert(not bc.btest(bc.number("0x12300678"), bc.number("0x000F_F000")))
    assert(bc.hex(bc.extract(bc.number("0x12345678"), 12, 8)) == "0x 0045")
    assert(bc.hex(bc.replace(bc.number("0x12345678"), 0xFF, 12, 8)) == "0x 123F F678")
    assert(bc.hex(bc.lshift(bc.number("0x12345678"), 8)) == "0x 0012 3456 7800")
    assert(bc.hex(bc.lshift(bc.number("0x12345678"), -8)) == "0x 0012 3456")
    assert(bc.hex(bc.rshift(bc.number("0x12345678"), 8)) == "0x 0012 3456")
    assert(bc.hex(bc.rshift(bc.number("0x12345678"), -8)) == "0x 0012 3456 7800")
end

if m then
    local pi = m.Float(math.pi)
    assert(tostring(pi) == "3.1415926535898")
    assert(pi.tonumber() == math.pi)
    --[[
print("pi", pi)

a = m.Int(42)
print("a", a, m.hex(a, 16), m.dec(a), m.oct(a, 32), m.bin(a, 8))

print("a+1", a+1, "a+0.1", a+0.1)
print("pi+1", pi+1, "pi+0.1", pi+0.1)
print("a-1", a-1, "a-0.1", a-0.1)
print("pi-1", pi-1, "pi-0.1", pi-0.1)
print("a*2", a*2, "a*0.5", (a*0.5).float)
print("pi*2", pi*2, "pi*0.5", pi*0.5)
print("a/2", a/2, "a/5", a/5)
print("pi/2", pi/2, "pi/5", pi/5)
print("a^2", a^2, "a^-1", a^-1, "a^0.5", a^0.5)
print("-a", -a, "-pi", -pi)
print("a==a", a==a, "pi==pi", pi==pi, "a<pi", a<pi, "a>pi", a>pi)
print("abs(a)", m.abs(a), "abs(pi)", m.abs(pi))
print("abs(-a)", m.abs(-a), "abs(-pi)", m.abs(-pi))
print("sin(pi)", m.sin(pi))
print("cos(pi)", m.cos(pi))
print("floor(pi)", m.floor(pi), "ceil(pi)", m.ceil(pi))
print("fmod(10.6, 0.3)", m.fmod(10.6, 0.3))
print("frexp(1234.5678)", m.frexp(1234.5678))
print("huge", m.huge)
print("ldexp(0.25, -1)", m.ldexp(0.25, -1))
print("log(1000)", m.log(1000), "log(1000, 10)", m.log(1000, 10))
print("max(pi, a)", m.max(pi, a))
print("min(pi, a)", m.min(pi, a))
print("modf(pi)", m.modf(pi))
print("pi", m.pi)
m.randomseed(12.6)
print("random()", m.random(), "random(10)", m.random(10), "random(10, 100)", m.random(10, 100))

A = 0x0FF0
B = 0x1234
print("not A", m.hex(m.bnot(A, 16)))
print("A and B", m.hex(m.band(A, B, 16)))
print("A or B", m.hex(m.bor(A, B, 16)))
print("A xor B", m.hex(m.bxor(A, B, 16)))
print("A btest B", m.btest(A, B, 16))
print("A btest ~A", m.btest(A, m.bnot(A, 16), 16))
print("extract(B, 4, 8)", m.hex(m.extract(B, 4, 8)))
print("replace(B, 0xAB, 4, 8)", m.hex(m.replace(B, 0xAB, 4, 8)))
print("lshift(B, 4)", m.hex(m.lshift(B, 4)), "lshift(B, -4)", m.hex(m.lshift(B, -4)))
print("rshift(B, -4)", m.hex(m.rshift(B, -4)), "rshift(B, 4)", m.hex(m.rshift(B, 4)))

print("div(10, 3)", m.div(10, 3), "mod(10, 3)", m.mod(10, 3))
print("divmod(10, 3)", m.divmod(10, 3))
    --]]
end

doc [[
bn: arbitrary precision library for Lua written in pure Lua
-----------------------------------------------------------

### basic bn functions

**bn.Int(x)** builds a big integer from a Lua number, a string or a big number

**bn.Rat(x)** builds a big rational from a Lua number, a string or a big number

**bn.Float(x)** builds a float from a Lua number, a string or a big number

**bn.tonumber(x)** converts a big number to a Lua number

**bn.tostring(x, base, bits), \_\_tostring(x)** converts a big number to a string

**\_\_unm(x)** returns `-x`

**\_\_add(x,y)** returns `x+y`

**\_\_sub(x,y)** returns `x-y`

**\_\_mul(x,y)** returns `x*y`

**\_\_div(x,y)** returns `x/y`

**\_\_idiv(x,y)** return `x // y`

**\_\_mod(x,y)** return `x mod y`

**bn.divmod(x,y)** returns `[x/y], x mod y`

**bn.powmod(x,y,m)** returns `x**y mod m`

**\_\_pow(x,y)** returns `x**y`

**\_\_eq(x,y), \_\_lt(x,y)** compares x and y

**x:iszero()** is true if x == 0

**x:isone()** is true if x == 1

**bn.zero, bn.one, bn.two** big representations of `0`, `1` and `2`

**bn.bin(x, bits)** returns a string representation of `x` in base 2 on `bits` bits

**bn.oct(x, bits)** returns a string representation of `x` in base 8 on `bits` bits

**bn.dec(x, bits)** returns a string representation of `x` in base 10 on `bits` bits

**bn.hex(x, bits)** returns a string representation of `x` in base 16 on `bits` bits

**bn.sep(s)** sets the digit separator ("_", " " or nil)

### Math and bitwise operators

Functions of the math, mathx and bit32 modules also exist in the bn module.
These functions produce bn numbers but may work internally with Lua numbers.
Do not expect these functions to be precise.

All the functions of mathx are in the math module.

]]

if bn then

    local x = bn.Int("0123456789012345678901234567890123456789")
    local y = bn.Int("9999999999999999999999999999999999999999")

    bn.sep("_")

    assert(x:tostring() == "123_456_789_012_345_678_901_234_567_890_123_456_789")
    assert((-x):tostring() == "-123_456_789_012_345_678_901_234_567_890_123_456_789")

    assert(bn.dec(x) == "123_456_789_012_345_678_901_234_567_890_123_456_789")
    assert(bn.dec(-x) == "-123_456_789_012_345_678_901_234_567_890_123_456_789")
    assert(bn.hex(x) == "0x_5CE0_E9A5_6015_FEC5_AADF_A328_AE39_8115")
    assert(bn.hex(-x) == "-0x_5CE0_E9A5_6015_FEC5_AADF_A328_AE39_8115")
    assert(bn.oct(x) == "0o_1347016464530012776613253375062425616300425")
    assert(bn.oct(-x) == "-0o_1347016464530012776613253375062425616300425")
    assert(bn.bin(x) == "0b_101_1100_1110_0000_1110_1001_1010_0101_0110_0000_0001_0101_1111_1110_1100_0101_1010_1010_1101_1111_1010_0011_0010_1000_1010_1110_0011_1001_1000_0001_0001_0101")
    assert(bn.bin(-x) == "-0b_101_1100_1110_0000_1110_1001_1010_0101_0110_0000_0001_0101_1111_1110_1100_0101_1010_1010_1101_1111_1010_0011_0010_1000_1010_1110_0011_1001_1000_0001_0001_0101")

    assert(bn.dec(x, 96) == "029_737_151_512_469_004_522_285_007_125")
    assert(bn.dec(-x, 96) == "049_491_011_001_795_333_071_258_943_211")
    assert(bn.hex(x, 96) == "0x_6015_FEC5_AADF_A328_AE39_8115")
    assert(bn.hex(-x, 96) == "0x_9FEA_013A_5520_5CD7_51C6_7EEB")
    assert(bn.oct(x, 96) == "0o_30012776613253375062425616300425")
    assert(bn.oct(-x, 96) == "0o_47765001164524402715352161477353")
    assert(bn.bin(x, 96) == "0b_0110_0000_0001_0101_1111_1110_1100_0101_1010_1010_1101_1111_1010_0011_0010_1000_1010_1110_0011_1001_1000_0001_0001_0101")
    assert(bn.bin(-x, 96) == "0b_1001_1111_1110_1010_0000_0001_0011_1010_0101_0101_0010_0000_0101_1100_1101_0111_0101_0001_1100_0110_0111_1110_1110_1011")

    assert(x:tonumber() == 0123456789012345678901234567890123456789.0)
    assert(x:toInt() == bn.Int(x) and x:toInt() == x)
    assert(x:toRat() == x)
    assert(x:toFloat() == bn.Float(0123456789012345678901234567890123456789.0))

    assert(x+y == bn.Int("10123456789012345678901234567890123456788"))
    assert(x+(-y) == bn.Int("-9876543210987654321098765432109876543210"))
    assert((-x)+y == bn.Int("9876543210987654321098765432109876543210"))
    assert((-x)+(-y) == bn.Int("-10123456789012345678901234567890123456788"))
    assert(x + bn.Rat(1,2) == bn.Rat("246913578024691357802469135780246913579", 2))
    assert(bn.Int(4) + bn.Float(0.1) == bn.Float(4.1))

    assert(x-y == bn.Int("-9876543210987654321098765432109876543210"))
    assert(x-(-y) == bn.Int("10123456789012345678901234567890123456788"))
    assert((-x)-y == bn.Int("-10123456789012345678901234567890123456788"))
    assert((-x)-(-y) == bn.Int("9876543210987654321098765432109876543210"))
    assert(x - bn.Rat(1,2) == bn.Rat("246913578024691357802469135780246913577", 2))
    assert(bn.Int(4) - bn.Float(0.1) == bn.Float(3.9))

    assert(x*y == bn.Int("1234567890123456789012345678901234567889876543210987654321098765432109876543211"))
    assert(x*(-y) == bn.Int("-1234567890123456789012345678901234567889876543210987654321098765432109876543211"))
    assert((-x)*y == bn.Int("-1234567890123456789012345678901234567889876543210987654321098765432109876543211"))
    assert((-x)*(-y) == bn.Int("1234567890123456789012345678901234567889876543210987654321098765432109876543211"))
    assert(x * bn.Rat(1,2) == bn.Rat(x, 2))
    assert(bn.Int(4) * bn.Float(0.1) == bn.Float(0.4))

    local q, r = bn.divmod(x, y); assert(q == bn.Int("0") and r == x)
    local q, r = bn.divmod(-x, y); assert(q == bn.Int("-1") and r == y-x)
    local q, r = bn.divmod(x, -y); assert(q == bn.Int("-1") and r == y-x)
    local q, r = bn.divmod(-x, -y); assert(q == bn.Int("0") and r == x)

    local q, r = bn.divmod(y, x); assert(q == bn.Int("81") and r == bn.Int("90000000009000000000900000000090"))
    local q, r = bn.divmod(-y, x); assert(q == bn.Int("-82") and r == bn.Int("123456699012345669901234566990123456699"))
    local q, r = bn.divmod(y, -x); assert(q == bn.Int("-82") and r == bn.Int("123456699012345669901234566990123456699"))
    local q, r = bn.divmod(-y, -x); assert(q == bn.Int("81") and r == bn.Int("90000000009000000000900000000090"))

    assert(x/y == bn.Rat("13717421", "1111111111"))
    assert(x/(-y) == -bn.Rat("13717421", "1111111111"))
    assert((-x)/y == -bn.Rat("13717421", "1111111111"))
    assert((-x)/(-y) == bn.Rat("13717421", "1111111111"))

    assert(y/x == bn.Rat("1111111111", "13717421"))
    assert(y/(-x) == bn.Rat("-1111111111", "13717421"))
    assert((-y)/x == bn.Rat("-1111111111", "13717421"))
    assert((-y)/(-x) == bn.Rat("1111111111", "13717421"))

    assert(x / bn.Rat(1,2) == bn.Int(x) * bn.Int(2))
    assert(bn.Int(4) / bn.Float(0.1) == bn.Float(40))

    assert((x*y)/y == x)
    assert((-x*y)/y == -x)
    assert((x*y)/-y == -x)
    assert((-x*y)/-y == x)

    assert(x^bn.Int("17") == x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x)
    assert(x^bn.Int("1") == x)
    assert(x^bn.Int("0") == bn.one)
    assert(x^bn.Int("-2") == bn.Rat(1, x*x))
    assert(bn.tonumber(x^bn.Rat(1,2)) == x:tonumber()^0.5)
    assert(bn.Int(4) ^ bn.Float(0.1) == bn.Float(4^0.1))

    assert(bn.powmod(x, bn.Int(42), y) == x^bn.Int(42) % y)

    assert(x==x) assert(x~=y)
    assert(x<=x) assert(x<=y) assert(x>=x) assert(y>=x)
    assert(x<y) assert(y>x)
    assert(not (x>=y)) assert(not (x>y))

    assert(x == bn.Rat(bn.Int(2)*x, 2)) assert(x ~= bn.Rat(bn.Int(2)*x, 3))
    assert(x <= bn.Rat(bn.Int(2)*x, 2)) assert(x <= bn.Rat(bn.Int(2)*x+bn.one, 2))
    assert(x >= bn.Rat(bn.Int(2)*x, 2)) assert(x >= bn.Rat(bn.Int(2)*x-bn.one, 2))
    assert(x < bn.Rat(bn.Int(2)*x+bn.one, 2)) assert(x > bn.Rat(bn.Int(2)*x-bn.one, 2))
    assert(not(x > bn.Rat(bn.Int(2)*x, 2))) assert(not(x < bn.Rat(bn.Int(2)*x, 2)))

    assert(bn.Int(4) == bn.Float(4)) assert(bn.Int(4) ~= bn.Float(4.01))
    assert(bn.Int(4) <= bn.Float(4)) assert(bn.Int(4) < bn.Float(4.01))
    assert(bn.Int(4) >= bn.Float(4)) assert(bn.Int(4) > bn.Float(3.99))

    assert(bn.Rat(x, y):tostring() == "13_717_421 / 1_111_111_111")
    assert(bn.Rat(x, -y):tostring() == "-13_717_421 / 1_111_111_111")
    assert(bn.Rat(-x, y):tostring() == "-13_717_421 / 1_111_111_111")
    assert(bn.Rat(-x, -y):tostring() == "13_717_421 / 1_111_111_111")
    assert(bn.Rat(y, x):tostring() == "1_111_111_111 / 13_717_421")

    assert(bn.Rat(x, y):tonumber() == 13717421/1111111111)
    assert(bn.Rat(x, y):toInt() == bn.Int(13717421/1111111111))
    assert(bn.Rat(x, y):toRat() == bn.Rat(x, y))
    assert(bn.Rat(x, y):toFloat() == bn.Float(13717421/1111111111))

    assert(bn.Rat(-x, y) == bn.Rat(x, -y))
    assert(bn.Rat(-x, y) == -bn.Rat(x, y))

    assert(bn.Rat(1, 2) + bn.Rat(3, 4) == bn.Rat(5, 4))
    assert(bn.Rat(1, 2) - bn.Rat(3, 4) == bn.Rat(-1, 4))
    assert(bn.Rat(1, 2) * bn.Rat(3, 4) == bn.Rat(3, 8))
    assert(bn.Rat(1, 2) / bn.Rat(3, 4) == bn.Rat(4, 6))

    assert(bn.Rat(1, 2) + bn.one == bn.Rat(3, 2))
    assert(bn.Rat(1, 2) - bn.one == bn.Rat(-1, 2))
    assert(bn.Rat(1, 2) * bn.Int(3) == bn.Rat(3, 2))
    assert(bn.Rat(1, 2) / bn.Int(3) == bn.Rat(1, 6))

    assert(bn.Rat(1, 2) + bn.Float(5.5) == bn.Float(0.5 + 5.5))
    assert(bn.Rat(1, 2) - bn.Float(5.5) == bn.Float(0.5 - 5.5))
    assert(bn.Rat(1, 2) * bn.Float(5.5) == bn.Float(0.5 * 5.5))
    assert(bn.Rat(1, 2) / bn.Float(5.5) == bn.Float(0.5 / 5.5))

    assert(bn.hex(bn.bnot(bn.Int("0xAA55 FFFF 0000"), 64), 64) == "0x_FFFF_55AA_0000_FFFF")
    assert(bn.hex(~bn.Int("0xAA55 FFFF 0000"), 64) == "0x_FFFF_55AA_0000_FFFF")

    assert(bn.hex(bn.band(bn.Int("0x12345678"), bn.Int("0x000F_F000")), 32) == "0x_0004_5000")
    assert(bn.hex(bn.Int("0x12345678") & bn.Int("0x000F_F000"), 32) == "0x_0004_5000")

    assert(bn.hex(bn.bor(bn.Int("0x12345678"), bn.Int("0x000F_F000")), 32) == "0x_123F_F678")
    assert(bn.hex(bn.Int("0x12345678") | bn.Int("0x000F_F000"), 32) == "0x_123F_F678")

    assert(bn.hex(bn.bxor(bn.Int("0xAAAA5555"), bn.Int("0x00FF_FF00")), 32) == "0x_AA55_AA55")
    assert(bn.hex(bn.Int("0xAAAA5555") ~ bn.Int("0x00FF_FF00"), 32) == "0x_AA55_AA55")

    assert(bn.btest(bn.Int("0x12345678"), bn.Int("0x000F_F000")))
    assert(not bn.btest(bn.Int("0x12300678"), bn.Int("0x000F_F000")))
    assert(bn.hex(bn.extract(bn.Int("0x12345678"), 12, 8), 16) == "0x_0045")
    assert(bn.hex(bn.replace(bn.Int("0x12345678"), bn.Int(0xFF), 12, 8)) == "0x_123F_F678")

    assert(bn.hex(bn.lshift(bn.Int("0x12345678"), 8), 48) == "0x_0012_3456_7800")
    assert(bn.hex(bn.lshift(bn.Int("0x12345678"), -8), 32) == "0x_0012_3456")
    assert(bn.hex(bn.rshift(bn.Int("0x12345678"), 8), 32) == "0x_0012_3456")
    assert(bn.hex(bn.rshift(bn.Int("0x12345678"), -8), 48) == "0x_0012_3456_7800")

    assert(bn.hex(bn.Int("0x12345678") << 8, 48) == "0x_0012_3456_7800")
    assert(bn.hex(bn.Int("0x12345678") << -8, 32) == "0x_0012_3456")
    assert(bn.hex(bn.Int("0x12345678") >> 8, 32) == "0x_0012_3456")
    assert(bn.hex(bn.Int("0x12345678") >> -8, 48) == "0x_0012_3456_7800")
end

doc [[
crypt: Cryptographic functions
------------------------------

The `crypt` package is a pure Lua package (i.e. not really fast).

**crypt.hex.encode(data)** encodes `data` in hexa.

**crypt.hex.decode(data)** decodes the hexa `data`.

**crypt.base64.encode(data)** encodes `data` in base64.

**crypt.base64.decode(data)** decodes the base64 `data`.

**crypt.crc32(data)** computes the CRC32 of `data`.

**crypt.shaXXX(data)** computes an SHA digest of `data`. `XXX` is 1, 224 or 256.

**crypt.AES(password [,keylen [,mode] ])** returns an AES codec.
`password` is the encryption/decryption key, `keylen` is the length
of the key (128 (default), 192 or 256), `mode` is the encryption/decryption
mode ("cbc" (default) or "ecb").
`crypt.AES` objects have two methods: `encrypt(data)` and `decrypt(data)`.

**crypt.BTEA(password)** returns a BTEA codec
(a tiny cipher with reasonable security and efficiency,
see http://en.wikipedia.org/wiki/XXTEA).
`password` is the encryption/decryption key (only the first 16 bytes are used).
`crypt.BTEA` objects have two methods: `encrypt(data)` and `decrypt(data)`.
BTEA encrypts 32-bit words so the length of data should be a multiple of 4
(if not, BTEA will add null padding at the end of data).

**crypt.RC4(password, drop)** return a RC4 codec
(a popular stream cypher, see http://en.wikipedia.org/wiki/RC4).
`password` is the encryption/decryption key.
`drop` is the numbre of bytes ignores before encoding (768 by default).
`crypt.RC4` returns the encryption/decryption function.

**crypt.random(bits)** returns a string with `bits` random bits.

]]

if crypt then
    local data = "The quick brown fox jumps over the lazy dog"
    -- hex
    assert(crypt.hex.encode(data) == "54686520717569636b2062726f776e20666f78206a756d7073206f76657220746865206c617a7920646f67")
    assert(crypt.hex.decode("54686520717569636b2062726f776e20666f78206a756d7073206f76657220746865206c617a7920646f67") == data)
    -- base64
    assert(crypt.base64.encode(data) == "VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==")
    assert(crypt.base64.decode("VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==") == data)
    -- crc32
    assert(crypt.crc32(data) == 0x414FA339)
    -- sha1
    assert(crypt.sha1(data) == "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12")
    -- sha224, sha256
    assert(crypt.sha224(data) == "730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525")
    assert(crypt.sha256(data) == "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
    -- aes
    local keylen = {128, 192, 256}
    local method = {"ecb", "cbc"}
    for i = 1, #keylen+1 do
    for j = 1, #method+1 do
    if not (keylen[i] == nil and method[j] ~= nil) then
        local aes = crypt.AES("my key", keylen[i], method[j])
        local aes2 = crypt.AES("your key", keylen[i], method[j])
        assert(aes.encrypt(data) ~= data)
        assert(aes.decrypt(aes.encrypt(data)) == data)
        assert(aes2.encrypt(data) ~= data)
        assert(aes2.decrypt(aes2.encrypt(data)) == data)
        assert(aes2.encrypt(data) ~= aes.encrypt(data))
        assert(not aes2.decrypt(aes.encrypt(data)))
        assert(not aes.decrypt(aes2.encrypt(data)))
    end
    end
    end
    -- rc4
    local rc4_in = crypt.RC4("my key")
    local rc4_out = crypt.RC4("my key")
    local rc4_in2 = crypt.RC4("your key")
    local rc4_out2 = crypt.RC4("your key")
    assert(rc4_out(rc4_in(data)) == data)
    assert(rc4_out2(rc4_in2(data)) == data)
    assert(rc4_out2(rc4_in(data)) ~= data)
    -- btea
    while #data % 4 ~= 0 do data = data.."." end
    local btea = crypt.BTEA("my key")
    local btea2 = crypt.BTEA("your key")
    assert(btea.encrypt(data) ~= data)
    assert(btea.decrypt(btea.encrypt(data)) == data)
    assert(btea2.encrypt(data) ~= data)
    assert(btea2.decrypt(btea2.encrypt(data)) == data)
    assert(btea2.encrypt(data) ~= btea.encrypt(data))
    -- random
    for size in iter{0, 8, 64, 128} do
        local r1 = crypt.random(size)
        local r2 = crypt.random(size)
        local r3 = crypt.random(size)
        assert(#r1 == math.max(size/8, 1))
        assert(#r2 == math.max(size/8, 1))
        assert(#r3 == math.max(size/8, 1))
        assert(not (r1==r2 and r2==r3))
        if z then -- random data shall not be compressible
            assert(#z.compress(r1) > #r1)
            assert(#z.compress(r2) > #r2)
            assert(#z.compress(r3) > #r3)
        end
    end
end

doc [[
curl: libcurl interface
-----------------------

[libcurl](http://curl.haxx.se/) is multiprotocol file transfer library.
This package is a simple Lua interface to libcurl.

This package is based on [Lua-cURL](http://luaforge.net/projects/lua-curl/)
and provides the same API plus a few higher level objects.

This package was introduced before `socket` which is based on `Lua Socket`.
I recommend using `socket` instead of `curl`.

**curl.FTP(url [, login, password])** creates an FTP object to connect to
the FTP server at `url`. `login` and `password` are optional.
Methods are:

- `cd(path)` changes the *current working directory*. No connection is
  made, `path` is just stored internally for later connections.

- `get(path)` retrieves `path`.

- `put(path, data)` sends and stores the string `data` to the file `path`.

- `rm(path)` deletes the file `path`.

- `mkdir(path)` creates the directory `path`.

- `rmdir(path)` deletes the directory `path`.

- `list(path)` returns an iterator listing the directory `path`.

FTP connections are made through the cURL easy interface, each request is in
fact an entire connection (and deconnection).

**curl.HTTP(url)** creates an HTTP object to connect to the HTTP server at `url`.
Methods are:

- `get(path)` retrieves `path`.

- `save(path [, name])` retrieves `path` and saves it to `name`.
  The default value of `name` is the basename of `path`.
]]

doc [[
fs: File System
---------------
]]

doc [[
**fs.getcwd()** returns the current working directory.

**fs.chdir(path)** changes the current directory to `path`.
]]

function rm_rf(path)
    if fs.stat(path) then
        for name in reverse(fs.walk(path)) do
            while fs.stat(name) do
                assert(fs.remove(name))
            end
        end
    end
end

do
    rm_rf "foo"
    local old_path = assert(fs.getcwd())
    assert(fs.mkdir "foo")
    assert(fs.chdir "foo")
    local new_path = assert(fs.getcwd())
    assert(fs.chdir '..')
    assert(fs.getcwd() == old_path)
    assert(fs.chdir "foo")
    assert(fs.getcwd() == new_path)
    assert(fs.chdir(old_path))
    assert(fs.getcwd() == old_path)
    rm_rf "foo"
end

doc [[
**fs.listdir([path])** returns the list of files and directories in
`path` (the default path is the current directory).

**fs.dir([path])** returns an iterator listing files and directories in
`path` (the default path is the current directory).

**fs.walk([path])** returns an iterator listing directory and file names
in `path` and its subdirectories (the default path is the current directory).

**fs.mkdir(path)** creates a new directory `path`.

**fs.rename(old_name, new_name)** renames the file `old_name` to `new_name`.

**fs.remove(name)** deletes the file `name`.
]]

do
    rm_rf "foo"
    assert(fs.mkdir("foo"))
    io.open("foo/file1.c", "w"):close()
    assert(fs.mkdir("foo/bar"))
    io.open("foo/file2.lua", "w"):close()
    io.open("foo/bar/file3.lua", "w"):close()
    local function check_foo(dir, path)
        assert(#dir == 3)
        assert(dir[1]~=dir[2] and dir[1]~=dir[3] and dir[2]~=dir[3])
        assert(dir[1]=="file1.c" or dir[1]=="file2.lua" or dir[1]=="bar", dir[1])
        assert(dir[2]=="file1.c" or dir[2]=="file2.lua" or dir[2]=="bar", dir[2])
        assert(dir[3]=="file1.c" or dir[3]=="file2.lua" or dir[3]=="bar", dir[3])
    end
    local foo = assert(fs.listdir("foo"))
    check_foo(foo, "foo")
    foo = assert(list(fs.dir("foo")))
    check_foo(foo, "foo")
    assert(fs.chdir("foo"))
    foo = assert(fs.listdir())
    check_foo(foo, ".")
    foo = assert(list(fs.dir()))
    check_foo(foo, ".")
    assert(fs.chdir(".."))
    local function check_foo2(dir)
        assert(#dir == 2)
        assert(dir[1]~=dir[2])
        assert(dir[1]=="file2.lua" or dir[1]=="bar2", dir[1])
        assert(dir[2]=="file2.lua" or dir[2]=="bar2", dir[2])
    end
    local names = {
        "foo",
            "foo/file1.c",
            "foo/file2.lua",
            "foo/bar",
                "foo/bar/file3.lua"
    }
    local i = 0
    for name in fs.walk "foo" do
        i = i + 1
        assert(name == names[i]:gsub("/", fs.sep))
    end
    assert(fs.remove("foo/file1.c"))
    assert(fs.rename("foo/bar", "foo/bar2"))
    check_foo2(fs.listdir("foo"))
    check_foo2(list(fs.dir("foo")))
    local function check_foo3(dir)
        assert(#dir == 1)
        assert(dir[1]=="file3.lua", dir[1])
    end
    assert(fs.remove("foo/bar2/file3.lua"))
    assert(fs.remove("foo/bar2"))
    assert(fs.rename("foo/file2.lua", "foo/file3.lua"))
    check_foo3(fs.listdir("foo"))
    check_foo3(list(fs.dir("foo")))
    assert(fs.remove("foo/file3.lua"))
    assert(#fs.listdir("foo")==0)
    rm_rf "foo"
end

doc [[
**fs.copy(source_name, target_name)** copies file `source_name` to `target_name`.
The attributes and times are preserved.
]]

do
    local content = string.rep(
        "I don't remember the question, but for sure, the answer is 42!\n",
        42*1000)
    local f = assert(io.open("answer", "wb"))
    f:write(content)
    f:close()
    assert(fs.touch("answer", 42))
    assert(fs.chmod("answer", fs.aR))
    assert(fs.copy("answer", "answer-2"))
    f = assert(io.open("answer-2", "rb"))
    assert(f:read("*a") == content)
    f:close()
    assert(fs.stat("answer-2").mode == fs.stat("answer").mode)
    assert(fs.stat("answer-2").mtime == 42)
    if sys.platform == "Windows" then
        assert(fs.chmod("answer", fs.aR, fs.aW))
        assert(fs.chmod("answer-2", fs.aR, fs.aW))
    end
    fs.remove("answer")
    fs.remove("answer-2")
end

doc [[
**fs.stat(name)** reads attributes of the file `name`.  Attributes are:

- `name`: name
- type: "file" or "directory"
- `size`: size in bytes
- `mtime`, `atime`, `ctime`: modification, access and creation times.
- `mode`: file permissions
- `uR`, `uW`, `uX`: user Read/Write/eXecute permissions
- `gR`, `gW`, `gX`: group Read/Write/eXecute permissions
- `oR`, `oW`, `oX`: other Read/Write/eXecute permissions

**fs.inode(name)** reads device and inode attributes of the file `name`.
Attributes are:

- `dev`, `ino`: device and inode numbers

]]

do
    local function check(name, attrs)
        local st = fs.stat(name)
        assert(st.name == attrs.name)
        if (st.type=="file") then assert(st.size == attrs.size) end
        assert(math.abs(st.mtime-attrs.mtime)<=1)
        assert(math.abs(st.atime-attrs.atime)<=1)
        assert(math.abs(st.ctime-attrs.ctime)<=1)
        assert(st.uR == attrs.uR)
        assert(st.uW == attrs.uW)
        assert(st.uX == attrs.uX)
        if sys.platform == 'Linux' then
            assert(st.gR == attrs.gR)
            assert(st.gW == attrs.gW)
            assert(st.gX == attrs.gX)
            assert(st.oR == attrs.oR)
            assert(st.oW == attrs.oW)
            assert(st.oX == attrs.oX)
        end
    end
    rm_rf "foo"
    fs.mkdir("foo")
    check("foo", { name="foo", type="directory",
                   mtime=os.time(), atime=os.time(), ctime=os.time(),
                   uR=true, uW=true, uX=true,
                   gR=true, gW=false, gX=true,
                   oR=true, oW=false, oX=true,
    })
    rm_rf "foo"
end

doc [[
**fs.chmod(name, other_file_name)** sets file `name` permissions as
file `other_file_name` (string containing the name of another file).

**fs.chmod(name, bit1, ..., bitn)** sets file `name` permissions as
`bit1` or ... or `bitn` (integers).
]]

do
    local function check(name, mode, uR, uW, uX, gR, gW, gX, oR, oW, oX)
        if sys.platform == 'Windows' then
            uR = true
            uX = false
        end
        if type(mode) == 'string' then
            assert(fs.chmod(name, mode))
        else
            assert(fs.chmod(name, table.unpack(mode)))
        end
        local st = fs.stat(name)
        assert(st.uR == uR)
        assert(st.uW == uW)
        assert(st.uX == uX)
    end
    fs.chmod("bar", fs.aR, fs.aW); fs.remove("bar")
    fs.remove("bar2")
    assert(io.open("bar", "w")):close()
    assert(io.open("bar2", "w")):close()
    check("bar", {fs.uX, fs.gW, fs.oR},
        false, false, true,
        false, true, false,
        true, false, false)
    check("bar2", {fs.aR, fs.aW, fs.aX},
        true, true, true,
        true, true, true,
        true, true, true)
    check("bar", "bar2",
        true, true, true,
        true, true, true,
        true, true, true)
    fs.remove("bar")
    fs.remove("bar2")
end

doc [[
**fs.touch(name)** sets the access time and the modification time of file `name` with the current time.

**fs.touch(name, number)** sets the access time and the modification time of file `name` with `number`.

**fs.touch(name, other_name)** sets the access time and the modification time of file `name` with the times of file `other_name`.
]]

do
    local function check(name, mtime, atime)
        local st = fs.stat(name)
        assert(math.abs(st.mtime-mtime)<=1)
        assert(math.abs(st.atime-atime)<=1)
    end
    local t0 = os.time()
    io.open("bar", "w"):close()
    io.open("bar2", "w"):close()
    assert(fs.touch("bar", 42))
    check("bar", 42, 42)
    assert(fs.touch("bar", "bar2"))
    check("bar", t0, t0)
    assert(fs.touch("bar", 42))
    check("bar", 42, 42)
    local t1 = os.time()
    assert(fs.touch("bar"))
    check("bar", t1, t1)
    fs.remove("bar")
    fs.remove("bar2")
end

doc [[
**fs.basename(path)** return the last component of path.

**fs.dirname(path)** return all but the last component of path.

**fs.absname(path)** return the absolute path name of path.
]]

do
    assert(fs.basename("/usr/bin/bash") == "bash")
    assert(fs.basename("/usr/bin/") == "bin")
    assert(fs.basename("C:\\bin\\bl.exe") == "bl.exe")
    assert(fs.basename("bl") == "bl")
    assert(fs.basename("/") == "")
    assert(fs.dirname("/usr/bin/bash") == "/usr/bin")
    assert(fs.dirname("/usr/bin/") == "/usr")
    assert(fs.dirname("C:\\bin\\bl.exe") == "C:\\bin")
    assert(fs.dirname("bl") == "")
    assert(fs.dirname("/") == "")
    assert(fs.absname("/usr/bin/bash") == "/usr/bin/bash")
    assert(fs.absname("C:\\foo.txt") == "C:\\foo.txt")
    assert(fs.absname("foo/bar") == fs.getcwd()..fs.sep.."foo/bar")
end

doc [[

**fs.sep** is the directory separator (/ or \\).

**fs.uR, fs.uW, fs.uX** are the User Read/Write/eXecute mask for `fs.chmod`.

**fs.gR, fs.gW, fs.gX** are the Group Read/Write/eXecute mask for `fs.chmod`.

**fs.oR, fs.oW, fs.oX** are the Other Read/Write/eXecute mask for `fs.chmod`.

**fs.aR, fs.aW, fs.aX** are All Read/Write/eXecute mask for `fs.chmod`.
]]

doc [[
lpeg, re: parsing library
-------------------------

Bonaluna parsing library is Lpeg.
Both lpeg and re modules are loaded when Bonaluna is started.

The documentation of these modules are available on Lpeg web site:
- [Lpeg](http://www.inf.puc-rio.br/~roberto/lpeg/)
- [Re](http://www.inf.puc-rio.br/~roberto/lpeg/re.html)
]]

doc [[
z, lzo, qlz, lz4, zlib, ucl, lzma: compression libraries
--------------------------------------------------------

Compression libraries are based on:

- [LZO](http://www.oberhumer.com/opensource/lzo/)
- [QuickLZ](http://www.quicklz.com/)
- [LZ4/LZ4HC](http://code.google.com/p/lz4/)
- [LZF](http://oldhome.schmorp.de/marc/liblzf.html)
- [ZLIB](http://www.zlib.net/)
- [UCL](http://www.oberhumer.com/opensource/ucl/)
- [XZ Utils](http://tukaani.org/xz/)

It's inspired by the [Lua Lzo module](http://lua-users.org/wiki/LuaModuleLzo).

Future versions of BonaLuna may remove or add some compression library.

Currently, only LZ4 is used in the default BonaLuna distribution
but you can change it in `setup`.
]]

doc [[
**z.compress(data)** compresses `data` using the best compressor and returns the compressed string.

**z.decompress(data)** decompresses `data` and returns the decompressed string.

**minilzo.compress(data)** compresses `data` with miniLZO and returns the compressed string.

**minilzo.decompress(data)** decompresses `data` with miniLZO and returns the decompressed string.

**lzo.compress(data)** compresses `data` with LZO and returns the compressed string.

**lzo.decompress(data)** decompresses `data` with LZO and returns the decompressed string.

**qlz.compress(data)** compresses `data` with QLZ and returns the compressed string.

**qlz.decompress(data)** decompresses `data` with QLZ and returns the decompressed string.

**lz4.compress(data)** compresses `data` with LZ4 and returns the compressed string.

**lz4.decompress(data)** decompresses `data` with LZ4 and returns the decompressed string.

**lz4hc.compress(data)** compresses `data` with LZ4HC and returns the compressed string.

**lz4hc.decompress(data)** decompresses `data` with LZ4HC and returns the decompressed string.

**lzf.compress(data)** compresses `data` with LZF and returns the compressed string.

**lzf.decompress(data)** decompresses `data` with LZF and returns the decompressed string.

**zlib.compress(data)** compresses `data` with ZLIB and returns the compressed string.

**zlib.decompress(data)** decompresses `data` with ZLIB and returns the decompressed string.

**ucl.compress(data)** compresses `data` with UCL and returns the compressed string.

**ucl.decompress(data)** decompresses `data` with UCL and returns the decompressed string.

**lzma.compress(data)** compresses `data` with XZ Utils and returns the compressed string.

**lzma.decompress(data)** decompresses `data` with XZ Utils and returns the decompressed string.
]]

if z then
    local a = "This is a test string..."
    local b = "And this is another test string!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    local big = string.rep("a lot of bytes; ", 100000)
    local libs = {"z", "minilzo", "lzo", "qlz", "lz4", "lz4hc", "lzf", "zlib", "ucl", "lzma"}
    for name in iter(libs) do
        local lib = _G[name]
        if lib then
            assert(lib.decompress(lib.compress("")) == "")
            assert(lib.decompress(lib.compress(a)) == a)
            assert(lib.decompress(lib.compress(b)) == b)
            assert(lib.decompress(lib.compress(big)) == big)
            assert(#lib.compress(big) < #big)
            local ok, err = lib.decompress("not a compressed string")
            assert(ok == nil and err == name..": not a compressed string")
        end
    end
end

doc [[
ps: Processes
-------------

**ps.sleep(n)** sleeps for `n` seconds.
]]

do
    local function check(nsec, niter)
        local t0 = os.time()
        for i = 1, niter do ps.sleep(nsec) end
        local t1 = os.time()
        assert(math.abs((t1-t0)/niter / nsec - 1.0) <= 1e-3)
    end
    --check(2, 1)
    --check(0.1, 50)
    --check(0.01, 500)
end

doc [[
rl: readline
------------

The rl (readline) package was initially inspired by
[ilua](https://github.com/ilua)
and adapted for BonaLuna.

**rl.read(prompt)** prints `prompt` and returns the string entered by the user.

**rl.add(line)** adds `line` to the readline history (Linux only).

]]

doc [[
ser: serialization
------------------

The ser package is written by Robin Wellner (https://github.com/gvx/Ser)
and integrated in BonaLuna in two functions:

**ser.serialize(table)** returns a string that can be evaluated to build
the initial `table`.

**ser.deserialize(src)** evaluates `src` and returns a table.
]]

do
    local s = ser.serialize({{42}, 43, 0/0, "42", 1/0, -1/0})
    local t = ser.deserialize(s)
    assert(t[1][1] == 42)
    assert(t[2] == 43)
    assert(t[3] ~= t[3]) -- nan != nan !!!
    assert(t[4] == "42")
    assert(t[5] == 2/0)
    assert(t[6] == -3/0)
    assert(#t == 6)
end

doc [[
strings: string module addendum
-------------------------------

BonaLuna adds a few functions to the builtin string module:

**string.split(s, sep, maxsplit, plain)** splits `s` using `sep` as a separator.
If `plain` is true, the separator is considered as plain text.
`maxsplit` is the maximum number of separators to find (ie the remaining string is returned unsplit.
This function returns a list of strings.

**string.gsplit(s, sep, maxsplit, plain)** splits the string as `string.split` but returns an iterator.

**string.lines(s)** splits `s` using '\n' as a separator and returns an iterator.

**string.ltrim(s), string.rtrim(s), string.trim(s)** remove left/right/both end spaces

]]

do

    local function assert_teq(t1, t2, t3)
        t1 = list(t1); t2 = list(t2); t3 = list(t3)
        assert(#t1 == #t2)
        assert(#t1 == #t3)
        for i = 1, #t1 do
            assert(t1[i] == t2[i])
            assert(t1[i] == t3[i])
        end
    end

    local s = "a,b,c"
        assert_teq(s:split(","), s:gsplit(","), {"a", "b", "c"})
        assert_teq(s:split(",", 1), s:gsplit(",", 1), {"a", "b,c"})
        assert_teq(s:split(",", 2), s:gsplit(",", 2), {"a", "b", "c"})
        assert_teq(s:split(",", 3), s:gsplit(",", 3), {"a", "b", "c"})

    local s = "a,b,c,"
        assert_teq(s:split(","), s:gsplit(","), {"a", "b", "c", ""})
        assert_teq(s:split(",", 1), s:gsplit(",", 1), {"a", "b,c,"})
        assert_teq(s:split(",", 2), s:gsplit(",", 2), {"a", "b", "c,"})
        assert_teq(s:split(",", 3), s:gsplit(",", 3), {"a", "b", "c", ""})
        assert_teq(s:split(",", 4), s:gsplit(",", 4), {"a", "b", "c", ""})

    local s = ",a,b,c"
        assert_teq(s:split(","), s:gsplit(","), {"", "a", "b", "c"})
        assert_teq(s:split(",", 1), s:gsplit(",", 1), {"", "a,b,c"})
        assert_teq(s:split(",", 2), s:gsplit(",", 2), {"", "a", "b,c"})
        assert_teq(s:split(",", 3), s:gsplit(",", 3), {"", "a", "b", "c"})
        assert_teq(s:split(",", 4), s:gsplit(",", 4), {"", "a", "b", "c"})

    local s = " \n   ab  \n  cd\r\nef   "
    local lines = list(s:lines())
    assert(#lines == 4)
    assert(lines[1] == " "       and lines[1]:ltrim() == ""      and lines[1]:rtrim() == ""      and lines[1]:trim() == "")
    assert(lines[2] == "   ab  " and lines[2]:ltrim() == "ab  "  and lines[2]:rtrim() == "   ab" and lines[2]:trim() == "ab")
    assert(lines[3] == "  cd"    and lines[3]:ltrim() == "cd"    and lines[3]:rtrim() == "  cd"  and lines[3]:trim() == "cd")
    assert(lines[4] == "ef   "   and lines[4]:ltrim() == "ef   " and lines[4]:rtrim() == "ef"    and lines[4]:trim() == "ef")

end

doc [[
socket: Lua Socket (and networking tools)
-----------------------------------------

The socket package is based on [Lua Socket](http://w3.impa.br/~diego/software/luasocket/)
and adapted for BonaLuna.

The documentation of `Lua Socket` is available at the [Lua Socket documentation web site](http://w3.impa.br/~diego/software/luasocket/reference.html).

This package also comes with the following functions.

**FTP(url [, login, password])** creates an FTP object to connect to
the FTP server at `url`. `login` and `password` are optional.
Methods are:

- `cd(path)` changes the current working directory.

- `pwd()` returns the current working directory.

- `get(path)` retrieves `path`.

- `put(path, data)` sends and stores the string `data` to the file `path`.

- `rm(path)` deletes the file `path`.

- `mkdir(path)` creates the directory `path`.

- `rmdir(path)` deletes the directory `path`.

- `list(path)` returns an iterator listing the directory `path`.
]]

doc [[
struct: (un)pack structures
---------------------------

The struct package is taken from
[Library for Converting Data to and from C Structs for Lua 5.1](http://www.inf.puc-rio.br/~roberto/struct/)
and adapted for BonaLuna.

**struct.pack(fmt, d1, d2, ...)** returns a string containing the values `d1`, `d2`, etc. packed according to the format string `fmt`.

**struct.unpack(fmt, s, [i])** returns the values packed in string `s` according to the format string `fmt`. An optional `i` marks where in `s` to start reading (default is 1). After the read values, this function also returns the index in `s` where it stopped reading, which is also where you should start to read the rest of the string.

**struct.size(fmt)** returns the size of a string formatted according to the format string `fmt`. For obvious reasons, the format string cannot contain neither the option `s` nor the option `c0`.
]]

do
    assert(struct.unpack("f", struct.pack("f", 1.0)) == 1.0)
    assert(struct.unpack("I4", struct.pack("f", 1.0)) == 0x3F800000)
end

doc [[
sys: System management
----------------------
]]

doc [[
**sys.hostname()** returns the host name.

**sys.domainname()** returns the domain name.

**sys.hostid()** returns the host id.
]]

do
    if platform == 'Linux' then
        assert(sys.hostname() == io.popen("hostname"):read("*l"))
        assert(sys.domainname() == io.popen("domainname"):read("*l"))
        assert(sys.hostid() == tonumber(io.popen("hostid"):read("*l"), 16))
    end
end

doc [[
**sys.platform** is `"Linux"` or `"Windows"`
]]

doc [[
Self running scripts
====================

It is possible to add scripts to the BonaLuna interpretor
to make a single executable file containing the interpretor
and some BonaLuna scripts.

This feature is inspired by
[srlua](http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#srlua).

`pegar.lua` parameters (command line interface)
-----------------------------------------------

**compile:on|off|min** turns compilation on, off or on when chunks are smaller than sources (`min` is the default value)

**compress:on|off|min** turns compression on, off or on when chunks are smaller than sources (`min` is the default value)

**read:original_interpretor** reads the initial interpretor

**lua:script.lua** adds a script to be executed at runtime

**lua:script.lua=realname.lua** as above but stored under a different name

**str:name=value** creates a global variable holding a string

**str:name=@filename** as above but the string is the content of a file

**file:name** adds a file to be created at runtime (the file is not overwritten if it already exists)

**file:name=realname** as above but stored under a different name

**dir:name** creates a directory at runtime

**write:new_executable** write a new executable containing the original interpretor and all the added items

When a path starts with `:`, it is relative to the executable path otherwise
it is relative to the current working directory.

`Pegar` class (useable in BonaLuna scripts)
-------------------------------------------

The class `Pegar` defines methods to build an executable.
The methods have the same name as the command line parameters:

**compile(mode)** turns compilation on, off or on

**compress(mode)** turns compression on, off or on

**read(original_interpretor)** reads the initial interpretor (if different from the running interpretor)

**lua(script[, realname])** adds a script to be executed at runtime

**str(name, value)** creates a global variable holding a string

**strf(name, filename)** as above but the string is the content of a file

**file(name[, realname])** adds a file to be created at runtime

**dir(name)** creates a directory at runtime

**write(new_executable)** write a new executable containing the original interpretor and all the added items

]]

do
    local stub = arg[-1]
    local compress, compile
    local big_file = string.rep("what a big file", 10000)
    local big_str = string.rep("what a big string", 10000)
    for compress in iter{'on', 'off', 'min'} do
    for compile in iter{'on', 'off', 'min'} do
    for interface in Pegar and iter{'cli', 'script'} or iter{"cli"} do
        rm_rf "tmp"
        assert(fs.mkdir "tmp")
        local f = io.open("tmp/hello.lua", "w")
        f:write [[#! the shebang that loadstring doesn't like
            assert(fs.basename(arg[-1]) == "hello.exe")
            assert(arg[0] == "hello.lua")
            assert(arg[1] == "a")
            assert(arg[2] == "b")
            assert(arg[3] == "c")
            assert(big_str == string.rep("what a big string", 10000))
            print(my_constant*14)
        ]]
        f:write("\n--"..string.rep("a big compressible and useless comment...", 10000).."\n")
        f:write("z = [["..string.rep("a big compressible and useless string...", 10000).."]]\n")
        f:close()
        f = io.open("tmp/exit.lua", "w")
        f:write [[ os.exit() ]]
        f:close()
        f = io.open("tmp/hello.flag", "w")
        f:write [[ hi ]]
        f:close()
        f = io.open("tmp/hello.big_file", "w")
        f:write(big_file)
        f:close()
        f = io.open("tmp/hello.big_str", "w")
        f:write(big_str)
        f:close()
        if interface == 'cli' then
            os.execute(stub.." ../tools/pegar.lua -q"..
                " compile:"..compile..
                " compress:"..compress..
                " read:"..stub..
                " file::/hello.flag2=tmp/hello.flag"..
                " file::/hello.big_file2=tmp/hello.big_file"..
                " str:big_str=@tmp/hello.big_str"..
                " dir:tmp/hello.dir"..
                " str:my_constant=3"..
                " lua:hello.lua=tmp/hello.lua"..
                " lua:exit.lua=tmp/exit.lua"..
                " write:tmp/hello.exe")
        else
            Pegar().quiet().
                compile(compile).
                compress(compress).
                file(":/hello.flag2", "tmp/hello.flag").
                file(":/hello.big_file2", "tmp/hello.big_file").
                strf("big_str", "tmp/hello.big_str").
                dir("tmp/hello.dir").
                str("my_constant", "3").
                lua("hello.lua", "tmp/hello.lua").
                lua("exit.lua", "tmp/exit.lua").
                write("tmp/hello.exe")
        end
        assert(fs.stat("tmp/hello.exe"))
        assert(tonumber(io.popen("tmp"..fs.sep.."hello.exe a b c"):read("*a")) == 42)
        f = io.open("tmp/hello.flag2", "rb")
        assert(f:read("*a") == [[ hi ]])
        f:close()
        f = io.open("tmp/hello.big_file", "rb")
        assert(f:read("*a") == big_file)
        f:close()
        assert(fs.stat("tmp/hello.dir").type == "directory")
    end
    end
    end
    rm_rf "tmp"
end

doc([[
External modules
================

Some external modules are available.

- [Lupy](https://github.com/uleelx/lupy): A small Python-style OO implementation
- [Tasks](https://github.com/uleelx/TCP-DNS-proxy): TCP DNS proxy which can get the RIGHT IP address. It includes a multi tasking package

]])

doc [[
Examples
========

This documentation has been generated by a BonaLuna script.
[bonaluna.lua](bonaluna.lua) also contains some tests.
]]

print "BonaLuna tests passed"
